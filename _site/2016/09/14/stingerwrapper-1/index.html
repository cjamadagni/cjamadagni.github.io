<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      StingerWrapper.jl - Part 1 &middot; Chirag Jamadagni's Website!
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h2>
        <a href="/">
          Chirag Jamadagni's Website!
        </a>
      </h2>
      <p class="lead">I read about code. Write a little of it too! This blog lists my experiences while playing with code.</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">Home</a>

      

      
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/about/">About</a>
          
        
      
        
          
            <a class="sidebar-nav-item" href="/archive/">Archive</a>
          
        
      
        
      
        
          
        
      
      <a class="sidebar-nav-item" href="http://cjamadagni.github.io/public/Rohit-Varkey-Thankachan-Resume.pdf" target="_blank">Resume</a>
    </nav>

    <p>&copy; 2017. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="post">
  <h1 class="post-title">StingerWrapper.jl - Part 1</h1>
  <span class="post-date">14 Sep 2016</span>
  <p><strong>This post will be the first among a series of blog posts describing my
experiences while developing <a href="https://github.com/rohitvarkey/StingerWrapper.jl">StingerWrapper.jl</a>,
a Julia interface to the <a href="https://github.com/stingergraph/stinger/">STINGER</a>
C package for dynamic graph analysis. I have been working on StingerWrapper along
with Dr. James Fairbanks.</strong></p>

<p>In this blog post, I will describe our experiments with mapping C structures to
Julia types and the design decisions we made to provide a Julia API to the STINGER
C library.</p>

<h3 id="julia-and-c">Julia and C</h3>

<p>Julia provides a C foreign function interface (FFI) to call C functions exposed
through a shared library. Using <code class="highlighter-rouge">ccall</code>s as documented <a href="http://docs.julialang.org/en/release-0.5/manual/calling-c-and-fortran-code/">here</a>, let’s us call C
functions while passing in the required parameters. Julia has a mapping of its
internal types to C which can be seen here and automatically casts the Julia
types to the C types. The <code class="highlighter-rouge">ccall</code> syntax is pretty long and easy to get
wrong for untrained users. Writing a Julia function to abstract away this ccall
from the users would be the first step to providing a Julia API to the C library.
For example, the <code class="highlighter-rouge">add</code> function is much easier for an end user to think about.</p>

<p><code class="highlighter-rouge">julia
import Libdl: dlopen, dlsym
libtest = dlopen("shared_library_name") #Open a shared library in Julia
function add(a::Int32, b::Float32)
    ccall(dlsym(libtest, :add_nums), Float32, (Int32, Float32), (1, 2))
end
</code></p>

<p>Julia also supports direct C structs mappings. Just defining a immutable
composite Julia type with the attributes and types of the C struct, let’s Julia
decode these structures. This means you can create objects in Julia, pass them to
C, let C do its thing and get it back to Julia.</p>

<p>```c
struct foo {
    int a;
    float b;
}</p>

<p>float sum(struct foo bar){
    return bar.a + bar.b;
}
```</p>

<p>```julia
immutable Foo
    a::Int32
    b::Float32
end</p>

<p>bar = Foo(1, 2.0)
ccall(dlsym(libtest, :sum), Float32, (Foo,), bar) #Returns 3.0!
```</p>

<p>However, there are a few restrictions. For example,  Julia does not support arrays
of unknown sizes. And the Stinger C struct has a zero size array allocated to it.
This stops us from using this clean method to work with the Stinger C structure.
:sad:</p>

<p>As we can’t make a Julia type with all the mappings to the Stinger C structure,
the approach we ended up using was to hand over the memory allocation parts to C
and keep a reference to that memory using a pointer in Julia as a handle to the
STINGER C object. To facilitate this, we created a wrapper type to just store the
handle to the pointer returned from C. We store this as a <code class="highlighter-rouge">Ptr{Void}</code>, because well,
“when in doubt, use void pointers!” - James.</p>

<p><code class="highlighter-rouge">julia
type Stinger
    handle::Ptr{Void}
end
</code></p>

<p>We defined the constructor of <code class="highlighter-rouge">Stinger</code> to call the C memory allocator for a STINGER C
structure on initialization of a <code class="highlighter-rouge">Stinger</code> type in Julia. This let’s users just
say <code class="highlighter-rouge">Stinger()</code> and the C memory is allocated and the pointer is stored as the handle
attribute.</p>

<p>Now that we’ve allocated memory, we need to free it too! A Julia <a href="http://docs.julialang.org/en/release-0.5/stdlib/base/?highlight=finalizer#Base.finalizer"><code class="highlighter-rouge">finalizer</code></a>
is registered that takes care of this. It ensures that the calls the corresponding
free function in C when the Julia garbage collector gets around to it. All of this
occurs transparently to the user, who does not need to worry about memory
management. Our wrapper type now looks like this.</p>

<p>```julia
type Stinger
    handle::Ptr{Void}</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#Default constructor to create a Stinger data structure
function Stinger()
    s = new(ccall(dlsym(stinger_core_lib, "stinger_new"), Ptr{Void}, ()))
    finalizer(s, stinger_free)
    s
end end
</code></pre>
</div>

<p>function stinger_free(x::Stinger)
    # To prevent segfaults
    if x.handle != C_NULL
        x.handle = ccall(dlsym(stinger_core_lib, “stinger_free”), Ptr{Void}, (Ptr{Void},), x)
    end
end
```</p>

<p>This basic definition will let us write convenience wrapper functions
that make <code class="highlighter-rouge">ccall</code>s to the STINGER C library. However, it is limited in terms of
being able to access or modify data directly from Julia and basically forces
us to call C to do anything useful. We will look at ways in which we can expose
the data to users in better way in part 2.</p>

</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/2016/09/21/stingerwrapper-3/">
            StingerWrapper.jl - Part 3
            <small>21 Sep 2016</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2016/09/20/stingerwrapper-2/">
            StingerWrapper.jl - Part 2
            <small>20 Sep 2016</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2014/12/08/hello-world/">
            Hello World!
            <small>08 Dec 2014</small>
          </a>
        </h3>
      </li>
    
</ul>
</div>

    </div>

  </body>
</html>
