<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      StingerWrapper.jl - Part 2 &middot; Chirag Jamadagni's Website!
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h2>
        <a href="/">
          Chirag Jamadagni's Website!
        </a>
      </h2>
      <p class="lead">I read about code. Write a little of it too! This blog lists my experiences while playing with code.</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">Home</a>

      

      
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/about/">About</a>
          
        
      
        
          
            <a class="sidebar-nav-item" href="/archive/">Archive</a>
          
        
      
        
      
        
          
        
      
      <a class="sidebar-nav-item" href="http://cjamadagni.github.io/public/Rohit-Varkey-Thankachan-Resume.pdf" target="_blank">Resume</a>
    </nav>

    <p>&copy; 2017. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="post">
  <h1 class="post-title">StingerWrapper.jl - Part 2</h1>
  <span class="post-date">20 Sep 2016</span>
  <p><strong>This post is the second among a series of blog posts describing my
experiences while developing <a href="https://github.com/rohitvarkey/StingerWrapper.jl">StingerWrapper.jl</a>,
a Julia interface to the <a href="https://github.com/stingergraph/stinger/">STINGER</a>
C package for dynamic graph analysis. I have been working on StingerWrapper along
with Dr. James Fairbanks.</strong></p>

<p>In this blog post, I will describe our experiments with loading and storing
C variables in Julia and the design decisions we made regarding this in StingerWrapper.jl.</p>

<p>As I mentioned in Part 1, we had to use a <code class="highlighter-rouge">Ptr{Void}</code> pointer  as a handle to
refer to the C STINGER object. However, we wanted to offer a Julia like syntax for
users to examine values and set values of the STINGER object rather than working
directly with the pointer.</p>

<p>The first step was to figure out how we could load values pointed to by
C pointers into Julia. We found the <code class="highlighter-rouge">unsafe_load</code> and <code class="highlighter-rouge">unsafe_store!</code> functions (<a href="http://docs.julialang.org/en/release-0.4/manual/calling-c-and-fortran-code/#accessing-data-through-a-pointer">docs</a>) which lets you access data from pointers.
<code class="highlighter-rouge">unsafe_load</code> lets you pass in a pointer and Julia will attempt to load an
object from that depending on the type parameter of the <code class="highlighter-rouge">Ptr</code> passed into it. It
also lets you specify an index to act as an offset. <code class="highlighter-rouge">unsafe_store!</code> attempts to
store the value passed in into the memory pointed to by the <code class="highlighter-rouge">Ptr</code>. The use of
both of these functions is considered unsafe as undefined behavior occurs if the
memory is not valid when accessed. (Julia will probably segfault).</p>

<p>At this point, we had 2 options.</p>

<ol>
  <li>Write a Julia type mapping the <code class="highlighter-rouge">Stinger</code> C structure and attempt to load that.</li>
  <li>Hand code <code class="highlighter-rouge">unsafe_load</code> and <code class="highlighter-rouge">unsafe_store!</code> for every field.</li>
</ol>

<p>We weren’t sure if option 1 would work because of the unknown sized arrays at the
end of the <code class="highlighter-rouge">STINGER</code> C structure definition. It wasn’t clear if Julia could automatically
decode C structures which had complete mappings between Julia and C <a href="[http://docs.julialang.org/en/release-0.5/manual/calling-c-and-fortran-code/#mapping-c-types-to-julia]">either</a>.
In order to figure out these questions, we decided to write a few tests and check
how Julia performs in these situations. We tried to see if <code class="highlighter-rouge">unsafe_load</code> and
<code class="highlighter-rouge">unsafe_store!</code> would work in the following cases:</p>

<ol>
  <li>A C structure with a complete Julia type mapping.</li>
  <li>A C structure with an unknown array at the end and a Julia mapping leaving
out the unknown array.</li>
</ol>

<p>Both of these implementations work, as shown by this <a href="https://github.com/rohitvarkey/Julia-C-Experiments">experiment</a>. So, we implemented a Julia mapping
for the <code class="highlighter-rouge">STINGER</code> C structure leaving out the unknown array. Now, we
could do a <code class="highlighter-rouge">unsafe_load</code> on the pointer handle to the <code class="highlighter-rouge">STINGER</code> C object, to
load a representation in Julia. We could then modify it and use <code class="highlighter-rouge">unsafe_store!</code>
to write it back to C. A workflow such as the following was possible at this
point.</p>

<p><code class="highlighter-rouge">julia
s = Stinger() #Creating a `Stinger` object with a handle to the `STINGER` C pointer
#The convert is required to tell Julia to decode as a `StingerGraph`
sgraph = unsafe_load(convert(Ptr{StingerGraph}, s.handle))
#Attributes available using normal Julia syntax to perform gets and sets on.
sgraph.max_nv = 100000
unsafe_store!((convert(Ptr{StingerGraph}, s.handle), s)
</code></p>

<p>Integrating this functionality with the wrapper type we
created in part 1 was our next goal. Here, we had to deal with a major restriction
that is brought about when working with a Julia type that has an incomplete
mapping to the C type like <code class="highlighter-rouge">STINGER</code>, i.e, <strong>Memory MUST be allocated in C.</strong>
This restriction is enforced because <code class="highlighter-rouge">STINGER</code>’s’ C internal functions make use
of the unknown size arrays, which will not be allocated if we let Julia handle
the memory allocation. A handle to the C allocated memory <strong>MUST</strong> be maintained
to be able to address this memory from Julia.</p>

<p>A major design decision at this point was:</p>

<ul>
  <li>Should we always maintain a Julia representation of the <code class="highlighter-rouge">Stinger</code> C object
using an eager approach?</li>
  <li>Or should we only load the representation on demand using a lazy approach?</li>
</ul>

<p>When using the eager approach, even though we can decode the C structure using a
pointer to a type in Julia, this does not update when the C memory updates. This puts
the onus on the package to maintain some sort of consistency with the C memory.
This could be done by making sure to do an <code class="highlighter-rouge">unsafe_load</code> every time a <code class="highlighter-rouge">ccall</code>
occurs. On using a lazy approach, we have the additional overhead of having to
load the memory when the user is trying to access it, rather than having an already
loaded object in Julia memory that can be accessed.</p>

<p>We explored the trade-offs that were occurring here in terms of complexity
with respect to <code class="highlighter-rouge">ccalls</code> and <code class="highlighter-rouge">loads</code> and summarized them in the following
table.</p>

<table>
  <thead>
    <tr>
      <th>Operation</th>
      <th>Eager</th>
      <th>Lazy</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>getfields</td>
      <td>Already cached</td>
      <td>Has to do a load</td>
    </tr>
    <tr>
      <td>setfields</td>
      <td>Store to pointer</td>
      <td>Store to pointer</td>
    </tr>
    <tr>
      <td>ccalls</td>
      <td>Has to be updated after every <code class="highlighter-rouge">ccall</code>. Loads occurring for every <code class="highlighter-rouge">ccall</code></td>
      <td>No op</td>
    </tr>
  </tbody>
</table>

<p>Using this table, it was obvious that had to choose between a design depending on
the number of  <code class="highlighter-rouge">ccalls</code> and <code class="highlighter-rouge">getfields</code> expected.
We modeled the time taken for set, load and ccalls in the following equation.</p>

<p><code class="highlighter-rouge">T = αS + βL + γC</code>, where S - number of sets, L - number of loads, C - number of ccalls</p>

<p>For the eager approach:</p>

<ul>
  <li>S = SF, number of setfields</li>
  <li>L = C, number of ccalls</li>
  <li>C = C</li>
</ul>

<p><code class="highlighter-rouge">Te = αSF + βC + γC</code></p>

<p>For the lazy approach:</p>

<ul>
  <li>S = SF, number of setfields</li>
  <li>L = GF, number of getfields</li>
  <li>C = C</li>
</ul>

<p><code class="highlighter-rouge">Tl = αSF + βCF + γC</code></p>

<p><code class="highlighter-rouge">Te - Tl = β(C - GF)</code></p>

<p>The workflow we expect from the user will
generally contain more <code class="highlighter-rouge">ccalls</code> than <code class="highlighter-rouge">getfields</code>.</p>

<p><code class="highlighter-rouge">
G &gt; CF
=&gt; Tl &lt; Te
</code></p>

<p>Hence, we decided to use the lazy approach.</p>

<p>We had one final design decision to make regarding the mapping.</p>

<ul>
  <li>On a <code class="highlighter-rouge">getfield</code> or a <code class="highlighter-rouge">setfield</code>, should we load/store the entire Julia representation to C?</li>
  <li>Or just load/store only the attribute that was demanded?</li>
</ul>

<p>The <code class="highlighter-rouge">STINGER</code> C structure
is not expected to change and we know the offsets for every field. Using the
entire Julia representation to store/load requires more memory transfer than just
storing/loading one field. We debated on whether loading the entire structure
would help with the caching, but figured that due to the temporal and spatial nature
of caches, loading just a field would also give us this favorable behavior.</p>

<p>In the next part, we will look at how we can provide users with a clean interface
to access the fields of a <code class="highlighter-rouge">Stinger</code> object and perform get and set operations.</p>

</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/2016/09/21/stingerwrapper-3/">
            StingerWrapper.jl - Part 3
            <small>21 Sep 2016</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2016/09/14/stingerwrapper-1/">
            StingerWrapper.jl - Part 1
            <small>14 Sep 2016</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2014/12/08/hello-world/">
            Hello World!
            <small>08 Dec 2014</small>
          </a>
        </h3>
      </li>
    
</ul>
</div>

    </div>

  </body>
</html>
