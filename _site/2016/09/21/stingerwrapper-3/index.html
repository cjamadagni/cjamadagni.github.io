<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      StingerWrapper.jl - Part 3 &middot; Chirag Jamadagni's Website!
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h2>
        <a href="/">
          Chirag Jamadagni's Website!
        </a>
      </h2>
      <p class="lead">I read about code. Write a little of it too! This blog lists my experiences while playing with code.</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">Home</a>

      

      
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/about/">About</a>
          
        
      
        
          
            <a class="sidebar-nav-item" href="/archive/">Archive</a>
          
        
      
        
      
        
          
        
      
      <a class="sidebar-nav-item" href="http://cjamadagni.github.io/public/Rohit-Varkey-Thankachan-Resume.pdf" target="_blank">Resume</a>
    </nav>

    <p>&copy; 2017. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="post">
  <h1 class="post-title">StingerWrapper.jl - Part 3</h1>
  <span class="post-date">21 Sep 2016</span>
  <p><strong>This post is the third among a series of blog posts describing my
experiences while developing <a href="https://github.com/rohitvarkey/StingerWrapper.jl">StingerWrapper.jl</a>,
a Julia interface to the <a href="https://github.com/stingergraph/stinger/">STINGER</a>
C package for dynamic graph analysis. I have been working on StingerWrapper along
with Dr. James Fairbanks.</strong></p>

<p>In part 1 and part 2, we looked at how we could interact between Julia and C,
including methods of loading and storing data between the 2 languages. As explained
in part 2, we decided to use a lazy approach to accessing data from C and only
load/store the required field instead of the whole object. In this post, we
will look at how we can abstract away the <code class="highlighter-rouge">unsafe_load</code> and <code class="highlighter-rouge">unsafe_store!</code>
functions from users and let them use Julia like syntax to access attributes.</p>

<p>Initially, we planned to overload the <code class="highlighter-rouge">getfield</code> and <code class="highlighter-rouge">setfield</code> functions to
make accessors on the <code class="highlighter-rouge">Stinger</code> wrapper type, make the calls to <code class="highlighter-rouge">unsafe_load</code>
and <code class="highlighter-rouge">unsafe_store!</code>. This would have let us use the normal Julia <code class="highlighter-rouge">a.b</code> syntax to
access fields. However, Julia does not allow overloading these core functions yet (<a href="https://github.com/JuliaLang/julia/issues/1974">JuliaLang/julia#1974</a>). Had this
been possible, we could have allowed users to use a workflow like</p>

<p><code class="highlighter-rouge">julia
s = Stinger()
s.max_nv = 100000 #setfield! - Should end up reflecting in C
s.max_nv #getfield! - Reads 100000 from C
</code></p>

<p>Julia does let us overload the <code class="highlighter-rouge">getindex</code> and the <code class="highlighter-rouge">setindex!</code> functions though.
These functions are called when the syntax <code class="highlighter-rouge">a[b]</code> or <code class="highlighter-rouge">a[b] = 1</code> are used.
Overloading these functions, we can provide users with the ability to access
<code class="highlighter-rouge">STINGER</code> fields from the <code class="highlighter-rouge">Stinger</code> wrapper type using the indexing syntax.
Julia language interop packages such as <a href="https://github.com/JuliaPy/PyCall.jl">PyCall.jl</a>
uses this method to provide syntactic sugar to their users. Following the PyCall
implementation, we can let users use <code class="highlighter-rouge">Symbol</code>s to access the fields.</p>

<p><code class="highlighter-rouge">julia
s = Stinger()
s[:max_nv] = 100000 #setindex! - Should end up reflecting in C
s[:max_nv] #getindex! - Should read latest value from C
</code></p>

<p>Unlike PyCall.jl which has to support generality, we know exactly what fields of
the <code class="highlighter-rouge">StingerGraph</code> type we need to expose to users. So we declared an
<code class="highlighter-rouge">Enum</code> using the <code class="highlighter-rouge">@enum</code> for all the fields that we need to expose. Leveraging
meta-programming made writing the <code class="highlighter-rouge">@enum</code> call much easier too :).
This allows dispatching on this <code class="highlighter-rouge">Enum</code> type (which we named <code class="highlighter-rouge">StingerFields</code>) for
<code class="highlighter-rouge">getindex</code> and <code class="highlighter-rouge">setindex!</code> with the following advantages:</p>

<ul>
  <li>Invalid fields error out naturally. No explicit check is required to confirm if
the <code class="highlighter-rouge">Symbol</code> is part of the names of the fields in <code class="highlighter-rouge">StingerGraph</code>.</li>
  <li>We can encode the offsets from the base pointer required to load each field as
the value of the <code class="highlighter-rouge">Enum</code> instance. An example <code class="highlighter-rouge">getindex</code> implementation is given below.</li>
</ul>

<p><code class="highlighter-rouge">julia
function getindex(x::Stinger, field::StingerFields)
    idx = Int(field)
    basepointer = convert(Ptr{fieldtype(StingerGraph, idx)}, x.handle)
    unsafe_load(basepointer, idx)
end
</code></p>

<p>The type introspection at runtime is required as there are 2 fields in <code class="highlighter-rouge">StingerGraph</code>,
<code class="highlighter-rouge">batch_time</code> and <code class="highlighter-rouge">update_time</code>, that are <code class="highlighter-rouge">Float64</code>s while all the others fields
are <code class="highlighter-rouge">Int64</code>s. This introduces a type instability that can cause potential
performance bottlenecks. Rather than taking this performance hit to allow for
rarely used fields such as <code class="highlighter-rouge">batch_time</code> and <code class="highlighter-rouge">update_time</code>, we implemented special
getter functions for them. We <a href="https://github.com/rohitvarkey/StingerWrapper.jl/commit/c78f3d7d54590e9e44ca4c9dc4a3e776c407bc5a">benchmarked</a> both these versions of <code class="highlighter-rouge">getindex</code>
with the following results for 10000000 samples.</p>

<table>
  <thead>
    <tr>
      <th><code class="highlighter-rouge">getindex</code> Type</th>
      <th>minimum time</th>
      <th>median time</th>
      <th>mean time</th>
      <th>maximum time</th>
      <th>memory estimate</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Type unstable</td>
      <td>366.00 ns (0.00% GC)</td>
      <td>398.00 ns (0.00% GC)</td>
      <td>433.29 ns (1.10% GC)</td>
      <td>14.44 ms (99.79% GC)</td>
      <td>32.00 bytes</td>
    </tr>
    <tr>
      <td>Type stable</td>
      <td>38.00 ns (0.00% GC)</td>
      <td>41.00 ns (0.00% GC)</td>
      <td>43.95 ns (0.00% GC)</td>
      <td>219.11 Î¼s (0.00% GC)</td>
      <td>0.00 bytes</td>
    </tr>
  </tbody>
</table>

<p>These results show an order of magnitute reduction in latency for these core
operations and completely eliminate the need for memory allocation and garbage collection.
Finally, the syntax users can use to get or set fields on the <code class="highlighter-rouge">Stinger</code> wrapper
time is</p>

<p>```julia
s = Stinger()</p>

<h1 id="general-field-access">General field access</h1>
<p>s[max_nv] = 100000
s[max_nv]</p>

<h1 id="specialized-methods-for-batchtime-and-updatetime">Specialized methods for <code class="highlighter-rouge">batch_time</code> and <code class="highlighter-rouge">update_time</code></h1>
<p>s[batch_time] #Error
get_batchtime(s) #Loads the batch time.
```</p>

<p>We will be working on setting up benchmarks and implementing a BFS implementation
in the next week.</p>

</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/2016/09/20/stingerwrapper-2/">
            StingerWrapper.jl - Part 2
            <small>20 Sep 2016</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2016/09/14/stingerwrapper-1/">
            StingerWrapper.jl - Part 1
            <small>14 Sep 2016</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2014/12/08/hello-world/">
            Hello World!
            <small>08 Dec 2014</small>
          </a>
        </h3>
      </li>
    
</ul>
</div>

    </div>

  </body>
</html>
